Final Review
    -Comprehensive
    -T bit records if in thread or handler mode (bit 24)
    -Reciprocal Multiplication
        x/k = x * (1/k) = {x*2^N/k] >> N
        //Make easy as possible
        If usinga  32 bit processor, use 
        Choose a register that holds the MSH
        If using an 8 bit cpu
        x/3 = [x*(2^8/5)]>>8
        x*(256/3) = (85*x)>>8
        
    -Transformation of multiplication
        24*x = (16+8)x
             = (2^4+2^3)x
             
        31x = (11111)x
              100000
                  -1
        -------------
              11111
              
    -Pointer arithmetic
        pointer + integer
            p + k -> address
            *(p+k)=0
            LDR R0,=0
            LDR R1,p
            LDR R2,k
            STR R0,[R1,R2,LSL#2]
        pointer - integer
        pointer - pointer
            p2 = p1 + k
            k = p2 - p1
            
            LDR R0,p2
            LDR R1,p1
            SUB R0,R0,R1
            ASR R0,R0,#2 ; VERY IMPORTANT
            STR R0,k
            
            ; ASR not the same as /2 if negative odd
    -Polled waiting
        Why is latency unpredictable?
        Most applications are infinite loops
        
        Ex. Check keyboard for kestroke, use PWL
            Not doing anything else while in a wait loop
            Could miss some critical event
            
    -Fixed point representational error
        1/3 = [0.33333]...3 != 1/3
        1/3 = .0101 = 5/16
        |1/3 - 5/16|
    -Setting a bit
        set 6th bit (bit 5)
        x|=(1<<5)
        
    -Assembly for loops
        for(k=1;k<100;k++) doit();
        
    The unsigned product of two 4-bit binary numbers is 0100 00102. 
    The 2â€™s complement signed product of the same two numbers is 1110 00102.
    What are the two 4-bit operands?
            unsigned 0100 0010
                     +4
            
            signed   1110 0010
                     -2
                     
                     unsigned MSH-x = signed MSH
                     4-6 = -2
                     
                     6(base 10) = 0110
                     11(base 10) = 1011
                     6-11 = 0110 - 1011
                     
     Should be able to estimate execution times
        -always worst case
                     
                     
                     
            
        